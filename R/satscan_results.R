# SaTScan Execution and Result Parsing
# Internal helpers for running SaTScan and parsing output

# Suppress R CMD check notes for NSE columns
utils::globalVariables(c("LOC_ID", "CLUSTER", "P_VALUE", "REL_RISK", "CLU_RR", "epid_link_id", "CLU_ODE", "id_char", "RR"))

#' Run SatScan Analysis
#'
#' Executes SatScan by calling the binary directly and parsing the output files.
#' Use `satscanr()` as the main entry point.
#'
#' @param work_dir Working directory with input files.
#' @param project_name Project name (default: "epid"). This matches the inputs CaseFile=epid.cas etc.
#' @param ss_location Path to the folder containing the SaTScan executable (Backwards compatibility param).
#' @param ss_batch Name of the SaTScan executable (Backwards compatibility param).
#' @param verbose Print output?
#' @return satscan result object
#' @keywords internal
run_satscan <- function(work_dir, project_name = "epid",
                        ss_location, ss_batch, verbose = FALSE) {
    if (verbose) message("Running SaTScan...")

    # 1. Resolve Binary Path
    # Combine location and batch name to get full path
    ss_bin <- file.path(ss_location, ss_batch)

    # Verify binary exists
    if (!file.exists(ss_bin)) {
        stop("SaTScan binary not found at: ", ss_bin)
    }

    # 2. Identify PRM file
    prm_file <- file.path(work_dir, paste0(project_name, ".prm"))
    if (!file.exists(prm_file)) {
        stop("PRM file not found at: ", prm_file)
    }

    # 3. Execute Binary
    tryCatch(
        {
            run_satscan_binary(prm_file, ss_bin, verbose = verbose)
        },
        error = function(e) {
            warning("SaTScan execution failed: ", e$message)
            return(NULL)
        }
    )

    # 4. Parse Output Files
    read_satscan_files(work_dir, project_name, verbose = verbose)
}

#' Read SaTScan Output Files
#'
#' Reads the output files (.col.dbf, .gis.dbf, etc.) generated by a SaTScan run.
#' This replaces `rsatscan`'s file reading logic.
#'
#' @param out_dir Directory where output files are located.
#' @param project_name Base name of the project (e.g. "epid").
#' @param verbose Logical.
#' @return A list mimicking the structure of `rsatscan` output for compatibility.
#' @keywords internal
read_satscan_files <- function(out_dir, project_name, verbose = FALSE) {
    # Helper for reading DBF if it exists
    read_dbf_safe <- function(suffix) {
        f <- file.path(out_dir, paste0(project_name, suffix))
        if (file.exists(f)) {
            # Use sf::st_read for DBF (it handles it well without 'foreign' dependency if sf is installed)
            # Or suppress warnings about "no geometry"
            tryCatch(
                suppressMessages(sf::st_read(f, quiet = TRUE)),
                error = function(e) NULL
            )
        } else {
            NULL
        }
    }

    # Helper for reading Shapefile
    read_shp_safe <- function(suffix_no_ext) {
        # sf expects path to .shp or folder
        f <- file.path(out_dir, paste0(project_name, suffix_no_ext))
        if (file.exists(f) || file.exists(paste0(f, ".shp"))) {
            tryCatch(
                suppressMessages(sf::st_read(f, quiet = !verbose)),
                error = function(e) NULL
            )
        } else {
            NULL
        }
    }

    if (verbose) message("Reading SaTScan output files from: ", out_dir)

    # Read components
    # .col.dbf - Cluster information
    col_df <- read_dbf_safe(".col.dbf")

    # .gis.dbf - Location information
    gis_df <- read_dbf_safe(".gis.dbf")

    # .rr.dbf - Relative risks
    rr_df <- read_dbf_safe(".rr.dbf")

    # .sci.dbf - Cluster information (secondary?)
    sci_df <- read_dbf_safe(".sci.dbf")

    # .llr.dbf - Log likelihood ratios
    llr_df <- read_dbf_safe(".llr.dbf")

    # Shapefile (.col.shp)
    shapeclust <- read_shp_safe(".col")

    # Main text output - we don't usually parse this in R but handy to have the path
    txt_file <- file.path(out_dir, paste0(project_name, ".txt"))
    main_txt <- if (file.exists(txt_file)) txt_file else NA

    # Construct list similar to rsatscan object
    res <- list(
        main = main_txt,
        col = col_df,
        rr = rr_df,
        gis = gis_df,
        llr = llr_df,
        sci = sci_df,
        shapeclust = shapeclust,
        prm = NULL # We could read the prm text here but satscanr object already separates it
    )

    # Clean up DBF columns if needed (sometimes sf reads them as factors or adds geometry col if empty)
    # Usually sf::st_read on a DBF returns a data.frame (or tbl_df).
    # If it returns sf object with empty geometry, drop it.

    clean_df <- function(df) {
        if (inherits(df, "sf")) sf::st_drop_geometry(df) else df
    }

    res$col <- clean_df(res$col)
    res$gis <- clean_df(res$gis)
    res$rr <- clean_df(res$rr)
    res$sci <- clean_df(res$sci)
    res$llr <- clean_df(res$llr)

    return(res)
}

#' Get macOS SatScan Path
#'
#' Handles macOS App Bundle path detection
#'
#' @param ss_full_path Full path to SatScan executable
#' @return List with ss_location and ss_batch
#' @keywords internal
get_macos_satscan_path <- function(ss_full_path) {
    ss_location <- dirname(ss_full_path)
    ss_batch <- basename(ss_full_path)

    # macOS App Bundle handling - use CLI binary, not GUI launcher
    if (Sys.info()["sysname"] == "Darwin" && ss_batch == "SaTScan") {
        if (basename(ss_location) == "MacOS") {
            alt_location <- file.path(dirname(ss_location), "app")
            alt_batch <- "satscan"
            if (file.exists(file.path(alt_location, alt_batch))) {
                ss_location <- alt_location
                ss_batch <- alt_batch
            }
        }
    }

    list(ss_location = ss_location, ss_batch = ss_batch)
}

#' Parse SaTScan Output into S3 Object
#'
#' @param ss_results Result from read_satscan_files()
#' @param geo_df Data frame from ss_geo() with location IDs and coordinates
#' @param loc_id_col Name of the location ID column in geo_df
#' @param keep_raw Logical. Include raw output files?
#' @param verbose Print debug info?
#' @return Object of class "satscan_result"
#' @keywords internal
parse_satscan_output <- function(ss_results, geo_df, loc_id_col,
                                 keep_raw = FALSE, verbose = FALSE) {
    # =========================================================================
    # 1. CLUSTERS (from .col) - pass through, sort by P_VALUE
    # =========================================================================
    clusters <- ss_results$col

    if (!is.null(clusters) && nrow(clusters) > 0) {
        if ("P_VALUE" %in% names(clusters)) {
            clusters <- clusters |> dplyr::arrange(.data$P_VALUE)
        }
        if (verbose) message("Clusters: ", nrow(clusters))
    } else {
        clusters <- NULL
        if (verbose) message("No clusters detected")
    }

    # =========================================================================
    # 2. LOCATIONS (geo + rr + gis merged)
    # =========================================================================

    # Start with geo_df, create LOC_ID for joining (SaTScan's key)
    locations <- geo_df |>
        dplyr::mutate(LOC_ID = as.character(.data[[loc_id_col]]))

    # Join .rr (relative risk for ALL locations)
    if (!is.null(ss_results$rr) && nrow(ss_results$rr) > 0) {
        rr_df <- ss_results$rr |>
            dplyr::mutate(LOC_ID = as.character(LOC_ID))

        # Handle potential column conflicts with suffix
        locations <- dplyr::left_join(locations, rr_df,
            by = "LOC_ID",
            suffix = c("", ".rr")
        )
    }

    # Join .gis (cluster membership - only locations IN clusters)
    if (!is.null(ss_results$gis) && nrow(ss_results$gis) > 0) {
        gis_df <- ss_results$gis |>
            dplyr::mutate(LOC_ID = as.character(LOC_ID))

        # Handle potential column conflicts with suffix
        locations <- dplyr::left_join(locations, gis_df,
            by = "LOC_ID",
            suffix = c("", ".gis")
        )
    }

    if (verbose) {
        n_total <- nrow(locations)
        n_in_cluster <- if ("CLUSTER" %in% names(locations)) {
            sum(!is.na(locations$CLUSTER))
        } else {
            0
        }
        message(sprintf("Locations: %d total, %d in clusters", n_total, n_in_cluster))
    }

    # =========================================================================
    # 3. BUILD RESULT
    # =========================================================================
    res <- list(
        clusters = clusters,
        locations = locations
    )

    if (keep_raw) {
        res$col <- ss_results$col
        res$gis <- ss_results$gis
        res$rr <- ss_results$rr
        res$sci <- ss_results$sci
        res$llr <- ss_results$llr
        res$shapeclust <- ss_results$shapeclust
        res$main <- ss_results$main
    }

    class(res) <- "satscan_result"
    res
}


# =============================================================================
# S3 METHODS
# =============================================================================

#' @export
print.satscan_result <- function(x, ...) {
    # Counts
    n_clusters <- if (!is.null(x$clusters)) nrow(x$clusters) else 0
    n_locs <- if (!is.null(x$locations)) nrow(x$locations) else 0

    # Significant clusters (if P_VALUE exists)
    n_sig <- 0
    if (n_clusters > 0 && "P_VALUE" %in% names(x$clusters)) {
        n_sig <- sum(x$clusters$P_VALUE < 0.05, na.rm = TRUE)
    }

    # Locations in clusters (if CLUSTER column exists)
    n_in_cluster <- 0
    if (n_locs > 0 && "CLUSTER" %in% names(x$locations)) {
        n_in_cluster <- sum(!is.na(x$locations$CLUSTER))
    }

    cat("SaTScan Result\n")
    cat("==============\n")
    cat(sprintf("Clusters:  %d (%d significant at p < 0.05)\n", n_clusters, n_sig))
    cat(sprintf("Locations: %d (%d in clusters)\n", n_locs, n_in_cluster))

    # Show top clusters
    if (n_sig > 0) {
        cat("\nTop Significant Clusters:\n")
        top <- x$clusters |>
            dplyr::filter(.data$P_VALUE < 0.05) |>
            head(5)
        print(top)
    }

    # Show available components
    cat("\nComponents: $clusters, $locations")
    if (!is.null(x$col)) cat(", $col, $gis, $rr (raw)")
    cat("\n")

    invisible(x)
}

#' @export
summary.satscan_result <- function(object, ...) {
    object$clusters
}
